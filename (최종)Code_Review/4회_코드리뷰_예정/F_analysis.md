# Django F() 객체 심층 분석: 위험성과 활용 빈도

`F()` 객체는 Django ORM의 강력한 무기이지만, 양날의 검과 같습니다. 잘못 사용하면 디버깅하기 힘든 버그를 만들어냅니다.

## 1. F() 객체의 4가지 치명적 위험성 (Risks)

### (1) 메모리와 DB의 불일치 (Dirty Instance)
가장 흔한 실수입니다. `F()`로 업데이트한 후, 해당 모델 인스턴스(메모리)는 여전히 **"과거의 값"**을 가지고 있습니다.

```python
stmt = "SELECT stock FROM product WHERE id=1" # DB: 10개
p = Product.objects.get(id=1) # 메모리: 10개

p.stock = F('stock') - 1
p.save() 
# DB: 9개 (UPDATE product SET stock = stock - 1 ...)
# 메모리(p.stock): F(stock) - 1 이라는 "수식 객체" 그 자체

p.stock = 5 # 만약 다른 로직에서 값을 덮어쓰고
p.save()    # 다시 저장한다면?
```
> **위험:** 만약 `p` 인스턴스를 계속 재사용해서 다른 필드를 수정하고 `.save()`를 또 호출하면, 방금 `F()`로 계산된 DB의 최신 값이 **메모리에 있던 덮어써진 값(또는 의도치 않은 값)**으로 변질될 수 있습니다.
> 
> **해결:** `update()` 직후에는 반드시 `p.refresh_from_db()`를 호출하여 메모리를 동기화해야 합니다.

### (2) `post_save` 시그널의 함정
Django의 `post_save` 시그널을 즐겨 쓴다면 치명적일 수 있습니다.
`F()`를 사용해 `save()`를 호출하면, 시그널 수신자(Receiver)에게 전달되는 `instance.stock` 값은 숫자가 아니라 **`F('stock') - 1`이라는 수식 객체 그 자체**입니다.

*   `if instance.stock < 0:` 같은 비교문이 시그널 안에 있다면? **에러 발생 (TypeError)**
*   시그널에서 로깅을 남긴다면? `Log: Stock changed to F(stock) - 1` 라고 찍힘 (무의미)

### (3) "비즈니스 로직" 검증 불가
`F()`는 DB에게 연산을 위임하므로, Python 레벨의 검증(`clean()`, `validate()`)을 우회합니다.
*   **상황:** "재고는 마이너스가 될 수 없다"는 로직이 모델 `clean()`에 있어도, `F('stock') - 100`을 날리면 DB는 그냥 마이너스로 만들어버릴 수 있습니다. (DB에 `PositiveIntegerField`나 `CHECK` 제약조건이 없다면)

### (4) 경쟁 조건 (Race Condition)의 "절반의 해결"
`F()`는 덮어쓰기(Lost Update)는 막아주지만, **논리적 무결성**까지 보장하진 않습니다.
*   **상황:** 재고가 1개 남았는데 2명이 동시에 주문.
    *   A 트랜잭션: `UPDATE ... SET stock = stock - 1` (성공, stock=0)
    *   B 트랜잭션: `UPDATE ... SET stock = stock - 1` (성공, stock=-1, **재앙 발생**)
*   `F()`는 "동시 차감"을 가능하게 할 뿐, "재고가 있을 때만 차감"하려면 `filter(stock__gt=0).update(...)` 구문과 결합해야만 안전합니다.

---

## 2. 실제 현업 사용 빈도 (Frequency Analysis)

개발자 100명에게 물어보면 **"알지만 자주는 안 쓴다(20%)"** 또는 **"특정 상황에서만 필수(80%)"**라고 답합니다.

### [빈도: 높음] 언제 "필수"로 쓰는가? (Top 3)
1.  **조회수/좋아요 카운터 증가**: 
    *   가장 압도적인 사용처. 동시성 문제가 빈번하고, 정확한 값보다 "증가 자체"가 중요하기 때문.
    *   `Post.objects.filter(pk=1).update(views=F('views') + 1)`
2.  **대량 데이터 일괄 업데이트**:
    *   전 사원 연봉 5% 인상 등. Python으로 1만 명을 불러와서 루프 돌리면 느려 터짐. `update(salary=F('salary') * 1.05)` 한 줄로 끝.
3.  **선착순/재고 차감 (쿼리 단건)**:
    *   `select_for_update()`가 너무 무겁다고 판단될 때, `filter(stock__gt=0).update(stock=F('stock') - 1)` 패턴으로 가볍게 처리.

### [빈도: 낮음] 언제 "피하는가"?
1.  **복잡한 계산 후 저장**: 업데이트할 값이 `현재 값 + 1` 수준이 아니라, 다른 테이블 조회하고 복잡한 수식을 거쳐야 한다면 그냥 Python 메모리에서 계산하고 `select_for_update`로 잠그는 게 낫습니다.
2.  **Save 메서드 오버라이딩이 많은 모델**: 모델의 `.save()`에 복잡한 로직이 많으면, `F()` 객체가 들어왔을 때 로직이 깨질 확률이 높아 기피합니다.

## 3. 요약 및 권장 전략

| 구분 | F() 사용 권장 | 일반 Python 할당 권장 |
| :--- | :--- | :--- |
| **성능** | **최상** (DB 내부 연산) | 보통 (SELECT 후 UPDATE) |
| **동시성** | **강력** (Lock 없이 덮어쓰기 방지) | 약함 (`select_for_update` 필수) |
| **안전성** | **주의 필요** (메모리 불일치, 시그널) | 안전 (직관적) |
| **주 용도** | 카운터, 벌크 업데이트, 단순 증감 | 상태 변경, 복잡한 비즈니스 로직 |

> **결론:** "조회수 증가" 같은 단순 숫자 놀음에는 **무조건** 쓰시고, "통장 잔고 차감"처럼 민감하고 로직이 복잡한 곳에는 `select_for_update`와 함께 **일반적인 값 할당** 방식을 쓰는 것이 정신 건강에 좋습니다.
